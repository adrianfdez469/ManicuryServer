module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateClient {
  count: Int!
}

type AggregateIngressOfWork {
  count: Int!
}

type AggregateSpendOfWork {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWorkType {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  id: ID!
  name: String!
  phone: String
  address: String
  imgUrl: String
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  id: ID
  name: String!
  phone: String
  address: String
  imgUrl: String
}

input ClientCreateOneInput {
  create: ClientCreateInput
  connect: ClientWhereUniqueInput
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  address_ASC
  address_DESC
  imgUrl_ASC
  imgUrl_DESC
}

type ClientPreviousValues {
  id: ID!
  name: String!
  phone: String
  address: String
  imgUrl: String
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
}

input ClientUpdateDataInput {
  name: String
  phone: String
  address: String
  imgUrl: String
}

input ClientUpdateInput {
  name: String
  phone: String
  address: String
  imgUrl: String
}

input ClientUpdateManyMutationInput {
  name: String
  phone: String
  address: String
  imgUrl: String
}

input ClientUpdateOneInput {
  create: ClientCreateInput
  update: ClientUpdateDataInput
  upsert: ClientUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ClientWhereUniqueInput
}

input ClientUpsertNestedInput {
  update: ClientUpdateDataInput!
  create: ClientCreateInput!
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  imgUrl: String
  imgUrl_not: String
  imgUrl_in: [String!]
  imgUrl_not_in: [String!]
  imgUrl_lt: String
  imgUrl_lte: String
  imgUrl_gt: String
  imgUrl_gte: String
  imgUrl_contains: String
  imgUrl_not_contains: String
  imgUrl_starts_with: String
  imgUrl_not_starts_with: String
  imgUrl_ends_with: String
  imgUrl_not_ends_with: String
  AND: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
}

scalar DateTime

type IngressOfWork {
  id: ID!
  workType: WorkType!
  client: Client
  ingressAmount: Float!
  tip: Float!
  date: DateTime
}

type IngressOfWorkConnection {
  pageInfo: PageInfo!
  edges: [IngressOfWorkEdge]!
  aggregate: AggregateIngressOfWork!
}

input IngressOfWorkCreateInput {
  id: ID
  workType: WorkTypeCreateOneInput!
  client: ClientCreateOneInput
  ingressAmount: Float!
  tip: Float!
}

type IngressOfWorkEdge {
  node: IngressOfWork!
  cursor: String!
}

enum IngressOfWorkOrderByInput {
  id_ASC
  id_DESC
  ingressAmount_ASC
  ingressAmount_DESC
  tip_ASC
  tip_DESC
  date_ASC
  date_DESC
}

type IngressOfWorkPreviousValues {
  id: ID!
  ingressAmount: Float!
  tip: Float!
  date: DateTime
}

type IngressOfWorkSubscriptionPayload {
  mutation: MutationType!
  node: IngressOfWork
  updatedFields: [String!]
  previousValues: IngressOfWorkPreviousValues
}

input IngressOfWorkSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IngressOfWorkWhereInput
  AND: [IngressOfWorkSubscriptionWhereInput!]
}

input IngressOfWorkUpdateInput {
  workType: WorkTypeUpdateOneRequiredInput
  client: ClientUpdateOneInput
  ingressAmount: Float
  tip: Float
}

input IngressOfWorkUpdateManyMutationInput {
  ingressAmount: Float
  tip: Float
}

input IngressOfWorkWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workType: WorkTypeWhereInput
  client: ClientWhereInput
  ingressAmount: Float
  ingressAmount_not: Float
  ingressAmount_in: [Float!]
  ingressAmount_not_in: [Float!]
  ingressAmount_lt: Float
  ingressAmount_lte: Float
  ingressAmount_gt: Float
  ingressAmount_gte: Float
  tip: Float
  tip_not: Float
  tip_in: [Float!]
  tip_not_in: [Float!]
  tip_lt: Float
  tip_lte: Float
  tip_gt: Float
  tip_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [IngressOfWorkWhereInput!]
}

input IngressOfWorkWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createIngressOfWork(data: IngressOfWorkCreateInput!): IngressOfWork!
  updateIngressOfWork(data: IngressOfWorkUpdateInput!, where: IngressOfWorkWhereUniqueInput!): IngressOfWork
  updateManyIngressOfWorks(data: IngressOfWorkUpdateManyMutationInput!, where: IngressOfWorkWhereInput): BatchPayload!
  upsertIngressOfWork(where: IngressOfWorkWhereUniqueInput!, create: IngressOfWorkCreateInput!, update: IngressOfWorkUpdateInput!): IngressOfWork!
  deleteIngressOfWork(where: IngressOfWorkWhereUniqueInput!): IngressOfWork
  deleteManyIngressOfWorks(where: IngressOfWorkWhereInput): BatchPayload!
  createSpendOfWork(data: SpendOfWorkCreateInput!): SpendOfWork!
  updateSpendOfWork(data: SpendOfWorkUpdateInput!, where: SpendOfWorkWhereUniqueInput!): SpendOfWork
  updateManySpendOfWorks(data: SpendOfWorkUpdateManyMutationInput!, where: SpendOfWorkWhereInput): BatchPayload!
  upsertSpendOfWork(where: SpendOfWorkWhereUniqueInput!, create: SpendOfWorkCreateInput!, update: SpendOfWorkUpdateInput!): SpendOfWork!
  deleteSpendOfWork(where: SpendOfWorkWhereUniqueInput!): SpendOfWork
  deleteManySpendOfWorks(where: SpendOfWorkWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWorkType(data: WorkTypeCreateInput!): WorkType!
  updateWorkType(data: WorkTypeUpdateInput!, where: WorkTypeWhereUniqueInput!): WorkType
  updateManyWorkTypes(data: WorkTypeUpdateManyMutationInput!, where: WorkTypeWhereInput): BatchPayload!
  upsertWorkType(where: WorkTypeWhereUniqueInput!, create: WorkTypeCreateInput!, update: WorkTypeUpdateInput!): WorkType!
  deleteWorkType(where: WorkTypeWhereUniqueInput!): WorkType
  deleteManyWorkTypes(where: WorkTypeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  ingressOfWork(where: IngressOfWorkWhereUniqueInput!): IngressOfWork
  ingressOfWorks(where: IngressOfWorkWhereInput, orderBy: IngressOfWorkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [IngressOfWork]!
  ingressOfWorksConnection(where: IngressOfWorkWhereInput, orderBy: IngressOfWorkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IngressOfWorkConnection!
  spendOfWork(where: SpendOfWorkWhereUniqueInput!): SpendOfWork
  spendOfWorks(where: SpendOfWorkWhereInput, orderBy: SpendOfWorkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SpendOfWork]!
  spendOfWorksConnection(where: SpendOfWorkWhereInput, orderBy: SpendOfWorkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SpendOfWorkConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  workType(where: WorkTypeWhereUniqueInput!): WorkType
  workTypes(where: WorkTypeWhereInput, orderBy: WorkTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkType]!
  workTypesConnection(where: WorkTypeWhereInput, orderBy: WorkTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkTypeConnection!
  node(id: ID!): Node
}

type SpendOfWork {
  id: ID!
  spendtype: String!
  spendamount: Float!
  date: DateTime
}

type SpendOfWorkConnection {
  pageInfo: PageInfo!
  edges: [SpendOfWorkEdge]!
  aggregate: AggregateSpendOfWork!
}

input SpendOfWorkCreateInput {
  id: ID
  spendtype: String!
  spendamount: Float!
}

type SpendOfWorkEdge {
  node: SpendOfWork!
  cursor: String!
}

enum SpendOfWorkOrderByInput {
  id_ASC
  id_DESC
  spendtype_ASC
  spendtype_DESC
  spendamount_ASC
  spendamount_DESC
  date_ASC
  date_DESC
}

type SpendOfWorkPreviousValues {
  id: ID!
  spendtype: String!
  spendamount: Float!
  date: DateTime
}

type SpendOfWorkSubscriptionPayload {
  mutation: MutationType!
  node: SpendOfWork
  updatedFields: [String!]
  previousValues: SpendOfWorkPreviousValues
}

input SpendOfWorkSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SpendOfWorkWhereInput
  AND: [SpendOfWorkSubscriptionWhereInput!]
}

input SpendOfWorkUpdateInput {
  spendtype: String
  spendamount: Float
}

input SpendOfWorkUpdateManyMutationInput {
  spendtype: String
  spendamount: Float
}

input SpendOfWorkWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  spendtype: String
  spendtype_not: String
  spendtype_in: [String!]
  spendtype_not_in: [String!]
  spendtype_lt: String
  spendtype_lte: String
  spendtype_gt: String
  spendtype_gte: String
  spendtype_contains: String
  spendtype_not_contains: String
  spendtype_starts_with: String
  spendtype_not_starts_with: String
  spendtype_ends_with: String
  spendtype_not_ends_with: String
  spendamount: Float
  spendamount_not: Float
  spendamount_in: [Float!]
  spendamount_not_in: [Float!]
  spendamount_lt: Float
  spendamount_lte: Float
  spendamount_gt: Float
  spendamount_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [SpendOfWorkWhereInput!]
}

input SpendOfWorkWhereUniqueInput {
  id: ID
}

type Subscription {
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  ingressOfWork(where: IngressOfWorkSubscriptionWhereInput): IngressOfWorkSubscriptionPayload
  spendOfWork(where: SpendOfWorkSubscriptionWhereInput): SpendOfWorkSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  workType(where: WorkTypeSubscriptionWhereInput): WorkTypeSubscriptionPayload
}

type User {
  id: ID!
  username: String!
  password: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  username: String
  password: String
}

input UserUpdateManyMutationInput {
  username: String
  password: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}

type WorkType {
  id: ID!
  name: String!
  price: Float!
}

type WorkTypeConnection {
  pageInfo: PageInfo!
  edges: [WorkTypeEdge]!
  aggregate: AggregateWorkType!
}

input WorkTypeCreateInput {
  id: ID
  name: String!
  price: Float!
}

input WorkTypeCreateOneInput {
  create: WorkTypeCreateInput
  connect: WorkTypeWhereUniqueInput
}

type WorkTypeEdge {
  node: WorkType!
  cursor: String!
}

enum WorkTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
}

type WorkTypePreviousValues {
  id: ID!
  name: String!
  price: Float!
}

type WorkTypeSubscriptionPayload {
  mutation: MutationType!
  node: WorkType
  updatedFields: [String!]
  previousValues: WorkTypePreviousValues
}

input WorkTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkTypeWhereInput
  AND: [WorkTypeSubscriptionWhereInput!]
}

input WorkTypeUpdateDataInput {
  name: String
  price: Float
}

input WorkTypeUpdateInput {
  name: String
  price: Float
}

input WorkTypeUpdateManyMutationInput {
  name: String
  price: Float
}

input WorkTypeUpdateOneRequiredInput {
  create: WorkTypeCreateInput
  update: WorkTypeUpdateDataInput
  upsert: WorkTypeUpsertNestedInput
  connect: WorkTypeWhereUniqueInput
}

input WorkTypeUpsertNestedInput {
  update: WorkTypeUpdateDataInput!
  create: WorkTypeCreateInput!
}

input WorkTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  AND: [WorkTypeWhereInput!]
}

input WorkTypeWhereUniqueInput {
  id: ID
}
`
      }
    